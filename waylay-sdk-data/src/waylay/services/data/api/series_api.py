# coding: utf-8
"""Waylay Broker api.

This code was generated from the OpenAPI documentation of 'Waylay Broker'

Generated by OpenAPI Generator (https://openapi-generator.tech)

Do not edit the class manually.
"""

from __future__ import annotations  # for Python 3.7â€“3.9

from typing import (
    TYPE_CHECKING,
    Any,
    Dict,
    List,
    Literal,
    TypeVar,
    overload,
)

from pydantic import (
    Field,
    StrictBool,
    StrictStr,
    TypeAdapter,
)
from typing_extensions import (
    Annotated,  # >=3.9,
)
from waylay.sdk.api import (
    HeaderTypes,
    QueryParamTypes,
    Response,
)
from waylay.sdk.api._models import Model
from waylay.sdk.plugin import WithApiClient

if TYPE_CHECKING:
    from waylay.services.data.models import (
        DeleteMessages200Response,
        ErrorResponse,
        GetSeries200ResponseInner,
        LatestMeasurement,
        QueryTimeSeries200Response,
        QueryTimeSeriesRequest,
        TimeseriesJsonResult,
    )
    from waylay.services.data.queries.series_api import (
        DeleteSeriesQuery,
        GetDatapointsForMetricRawQuery,
        GetLastDatapointsForMetricQuery,
        GetLastMetricQuery,
        GetMetricSeriesQuery,
        GetSeriesQuery,
        QueryTimeSeriesQuery,
    )


try:
    from waylay.services.data.models import (
        DeleteMessages200Response,
        ErrorResponse,
        GetSeries200ResponseInner,
        LatestMeasurement,
        QueryTimeSeries200Response,
        QueryTimeSeriesRequest,
        TimeseriesJsonResult,
    )
    from waylay.services.data.queries.series_api import (
        DeleteSeriesQuery,
        GetDatapointsForMetricRawQuery,
        GetLastDatapointsForMetricQuery,
        GetLastMetricQuery,
        GetMetricSeriesQuery,
        GetSeriesQuery,
        QueryTimeSeriesQuery,
    )

    MODELS_AVAILABLE = True
except ImportError:
    MODELS_AVAILABLE = False

    if not TYPE_CHECKING:
        DeleteSeriesQuery = dict
        DeleteMessages200Response = Model

        ErrorResponse = Model

        GetDatapointsForMetricRawQuery = dict
        TimeseriesJsonResult = Model

        ErrorResponse = Model

        GetLastDatapointsForMetricQuery = dict
        TimeseriesJsonResult = Model

        ErrorResponse = Model

        GetLastMetricQuery = dict
        LatestMeasurement = Model

        ErrorResponse = Model

        GetMetricSeriesQuery = dict
        TimeseriesJsonResult = Model

        ErrorResponse = Model

        GetSeriesQuery = dict
        GetSeries200ResponseInner = Model

        QueryTimeSeriesRequest = Model

        QueryTimeSeriesQuery = dict
        QueryTimeSeries200Response = Model

        ErrorResponse = Model


T = TypeVar("T")


class SeriesApi(WithApiClient):
    """SeriesApi service methods.

    NOTE: This class is auto generated by OpenAPI Generator
    Ref: https://openapi-generator.tech

    Do not edit the class manually.
    """

    @overload
    async def delete_series(
        self,
        resource_id: Annotated[
            StrictStr, Field(description="Uniquely identifies a resource.")
        ],
        *,
        query: DeleteSeriesQuery | QueryParamTypes | None = None,
        raw_response: Literal[False] = False,
        select_path: Literal[""] = "",
        response_type: Literal[None] = None,
        headers: HeaderTypes | None = None,
        **kwargs,
    ) -> DeleteMessages200Response: ...

    @overload
    async def delete_series(
        self,
        resource_id: Annotated[
            StrictStr, Field(description="Uniquely identifies a resource.")
        ],
        *,
        query: DeleteSeriesQuery | QueryParamTypes | None = None,
        raw_response: Literal[False] = False,
        select_path: Literal[""] = "",
        response_type: T,
        headers: HeaderTypes | None = None,
        **kwargs,
    ) -> T: ...

    @overload
    async def delete_series(
        self,
        resource_id: Annotated[
            StrictStr, Field(description="Uniquely identifies a resource.")
        ],
        *,
        query: DeleteSeriesQuery | QueryParamTypes | None = None,
        raw_response: Literal[True],
        select_path: Literal["_not_used_"] = "_not_used_",
        response_type: Literal[None] = None,  # not used
        headers: HeaderTypes | None = None,
        **kwargs,
    ) -> Response: ...

    @overload
    async def delete_series(
        self,
        resource_id: Annotated[
            StrictStr, Field(description="Uniquely identifies a resource.")
        ],
        *,
        query: DeleteSeriesQuery | QueryParamTypes | None = None,
        raw_response: Literal[False] = False,
        select_path: str,
        response_type: Literal[None] = None,
        headers: HeaderTypes | None = None,
        **kwargs,
    ) -> Model: ...

    @overload
    async def delete_series(
        self,
        resource_id: Annotated[
            StrictStr, Field(description="Uniquely identifies a resource.")
        ],
        *,
        query: DeleteSeriesQuery | QueryParamTypes | None = None,
        raw_response: Literal[False] = False,
        select_path: str,
        response_type: T,
        headers: HeaderTypes | None = None,
        **kwargs,
    ) -> T: ...

    async def delete_series(
        self,
        resource_id: Annotated[
            StrictStr, Field(description="Uniquely identifies a resource.")
        ],
        *,
        query: DeleteSeriesQuery | QueryParamTypes | None = None,
        raw_response: StrictBool = False,
        select_path: str = "",
        response_type: T | None = None,
        headers: HeaderTypes | None = None,
        **kwargs,
    ) -> DeleteMessages200Response | T | Response | Model:
        """Delete Series.

        Removes all timeseries associated with a resource.
        :param resource_id: Uniquely identifies a resource. (required)
        :type resource_id: str
        :param query: URL Query parameters.
        :type query: DeleteSeriesQuery | QueryParamTypes, optional
        :param query['from'] (dict) <br> query.var_from (Query) : Specifies the lower bound of the time period
        :type query['from']: DeleteSeriesFromParameter
        :param query['until'] (dict) <br> query.until (Query) : Specifies the upper bound of the time period
        :type query['until']: DeleteSeriesFromParameter
        :param raw_response: If true, return the http Response object instead of returning an api model object, or throwing an ApiError.
        :param select_path: Denotes the json path applied to the response object before returning it.
                Set it to the empty string `""` to receive the full response object.
        :param response_type: If specified, the response is parsed into an instance of the specified type.
        :param headers: Header parameters for this request
        :type headers: dict, optional
        :param `**kwargs`: Additional parameters passed on to the http client.
            See below.
        :Keyword Arguments:
            * timeout: a single numeric timeout in seconds,
                or a tuple of _connect_, _read_, _write_ and _pool_ timeouts.
            * stream: if true, the response will be in streaming mode
            * cookies
            * extensions
            * auth
            * follow_redirects: bool

        :return: Returns the result object if the http request succeeded with status code '2XX'.
        :raises APIError: If the http request has a status code different from `2XX`. This
            object wraps both the http Response and any parsed data.
        """

        should_validate = (
            MODELS_AVAILABLE and self.api_client.config.client_side_validation
        )

        # path parameters
        path_params: Dict[str, str] = {
            "resourceId": str(resource_id),
        }

        ## named body parameters
        body_args: Dict[str, Any] = {}

        # query parameters
        if query is not None and should_validate:
            query = TypeAdapter(DeleteSeriesQuery).validate_python(query)

        response_types_map: Dict[str, Any] = (
            {"2XX": response_type}
            if response_type is not None
            else {
                "200": DeleteMessages200Response if not select_path else Model,
            }
        )
        non_200_response_types_map: Dict[str, Any] = {
            "400": ErrorResponse,
        }
        response_types_map.update(non_200_response_types_map)

        ## peform request
        return await self.api_client.request(
            method="DELETE",
            resource_path="/data/v1/series/{resourceId}",
            path_params=path_params,
            params=query,
            **body_args,
            headers=headers,
            **kwargs,
            response_type=response_types_map,
            select_path=select_path,
            raw_response=raw_response,
        )

    @overload
    async def get_datapoints_for_metric_raw(
        self,
        resource_id: Annotated[
            StrictStr, Field(description="Uniquely identifies a resource.")
        ],
        metric: Annotated[
            StrictStr, Field(description="Identifies the times series metric.")
        ],
        *,
        query: GetDatapointsForMetricRawQuery | QueryParamTypes | None = None,
        raw_response: Literal[False] = False,
        select_path: Literal[""] = "",
        response_type: Literal[None] = None,
        headers: HeaderTypes | None = None,
        **kwargs,
    ) -> TimeseriesJsonResult: ...

    @overload
    async def get_datapoints_for_metric_raw(
        self,
        resource_id: Annotated[
            StrictStr, Field(description="Uniquely identifies a resource.")
        ],
        metric: Annotated[
            StrictStr, Field(description="Identifies the times series metric.")
        ],
        *,
        query: GetDatapointsForMetricRawQuery | QueryParamTypes | None = None,
        raw_response: Literal[False] = False,
        select_path: Literal[""] = "",
        response_type: T,
        headers: HeaderTypes | None = None,
        **kwargs,
    ) -> T: ...

    @overload
    async def get_datapoints_for_metric_raw(
        self,
        resource_id: Annotated[
            StrictStr, Field(description="Uniquely identifies a resource.")
        ],
        metric: Annotated[
            StrictStr, Field(description="Identifies the times series metric.")
        ],
        *,
        query: GetDatapointsForMetricRawQuery | QueryParamTypes | None = None,
        raw_response: Literal[True],
        select_path: Literal["_not_used_"] = "_not_used_",
        response_type: Literal[None] = None,  # not used
        headers: HeaderTypes | None = None,
        **kwargs,
    ) -> Response: ...

    @overload
    async def get_datapoints_for_metric_raw(
        self,
        resource_id: Annotated[
            StrictStr, Field(description="Uniquely identifies a resource.")
        ],
        metric: Annotated[
            StrictStr, Field(description="Identifies the times series metric.")
        ],
        *,
        query: GetDatapointsForMetricRawQuery | QueryParamTypes | None = None,
        raw_response: Literal[False] = False,
        select_path: str,
        response_type: Literal[None] = None,
        headers: HeaderTypes | None = None,
        **kwargs,
    ) -> Model: ...

    @overload
    async def get_datapoints_for_metric_raw(
        self,
        resource_id: Annotated[
            StrictStr, Field(description="Uniquely identifies a resource.")
        ],
        metric: Annotated[
            StrictStr, Field(description="Identifies the times series metric.")
        ],
        *,
        query: GetDatapointsForMetricRawQuery | QueryParamTypes | None = None,
        raw_response: Literal[False] = False,
        select_path: str,
        response_type: T,
        headers: HeaderTypes | None = None,
        **kwargs,
    ) -> T: ...

    async def get_datapoints_for_metric_raw(
        self,
        resource_id: Annotated[
            StrictStr, Field(description="Uniquely identifies a resource.")
        ],
        metric: Annotated[
            StrictStr, Field(description="Identifies the times series metric.")
        ],
        *,
        query: GetDatapointsForMetricRawQuery | QueryParamTypes | None = None,
        raw_response: StrictBool = False,
        select_path: str = "",
        response_type: T | None = None,
        headers: HeaderTypes | None = None,
        **kwargs,
    ) -> TimeseriesJsonResult | T | Response | Model:
        """Get Unaggregated Values For A Series.

        Retrieves the raw, unaggregated values for a series.  When a request with content type `application/hal+json` leads to more datapoints in the requested interval than the `limit` parameter allows, then the response contains a HAL `_links.next` url that resolves to a  next batch of datapoints.
        :param resource_id: Uniquely identifies a resource. (required)
        :type resource_id: str
        :param metric: Identifies the times series metric. (required)
        :type metric: str
        :param query: URL Query parameters.
        :type query: GetDatapointsForMetricRawQuery | QueryParamTypes, optional
        :param query['from'] (dict) <br> query.var_from (Query) : Specifies the lower bound of the time period. If not specified, a period of 7 days before `until` (or before the request was received) will be queried.
        :type query['from']: GetMetricSeriesFromParameter
        :param query['until'] (dict) <br> query.until (Query) : Specifies the upper bound of the time period. If not specified, a period of 7 days after `from` (or before the request was received) will be queried
        :type query['until']: GetMetricSeriesFromParameter
        :param query['limit'] (dict) <br> query.limit (Query) : max number of values to retrieve
        :type query['limit']: int
        :param query['order'] (dict) <br> query.order (Query) : sort order
        :type query['order']: Order
        :param raw_response: If true, return the http Response object instead of returning an api model object, or throwing an ApiError.
        :param select_path: Denotes the json path applied to the response object before returning it.
                Set it to the empty string `""` to receive the full response object.
        :param response_type: If specified, the response is parsed into an instance of the specified type.
        :param headers: Header parameters for this request
        :type headers: dict, optional
        :param `**kwargs`: Additional parameters passed on to the http client.
            See below.
        :Keyword Arguments:
            * timeout: a single numeric timeout in seconds,
                or a tuple of _connect_, _read_, _write_ and _pool_ timeouts.
            * stream: if true, the response will be in streaming mode
            * cookies
            * extensions
            * auth
            * follow_redirects: bool

        :return: Returns the result object if the http request succeeded with status code '2XX'.
        :raises APIError: If the http request has a status code different from `2XX`. This
            object wraps both the http Response and any parsed data.
        """

        should_validate = (
            MODELS_AVAILABLE and self.api_client.config.client_side_validation
        )

        # path parameters
        path_params: Dict[str, str] = {
            "resourceId": str(resource_id),
            "metric": str(metric),
        }

        ## named body parameters
        body_args: Dict[str, Any] = {}

        # query parameters
        if query is not None and should_validate:
            query = TypeAdapter(GetDatapointsForMetricRawQuery).validate_python(query)

        response_types_map: Dict[str, Any] = (
            {"2XX": response_type}
            if response_type is not None
            else {
                "200": TimeseriesJsonResult if not select_path else Model,
            }
        )
        non_200_response_types_map: Dict[str, Any] = {
            "400": ErrorResponse,
        }
        response_types_map.update(non_200_response_types_map)

        ## peform request
        return await self.api_client.request(
            method="GET",
            resource_path="/data/v1/series/{resourceId}/{metric}/raw",
            path_params=path_params,
            params=query,
            **body_args,
            headers=headers,
            **kwargs,
            response_type=response_types_map,
            select_path=select_path,
            raw_response=raw_response,
        )

    @overload
    async def get_last_datapoints_for_metric(
        self,
        resource_id: Annotated[
            StrictStr, Field(description="Uniquely identifies a resource.")
        ],
        metric: Annotated[
            StrictStr, Field(description="Identifies the times series metric.")
        ],
        *,
        query: GetLastDatapointsForMetricQuery | QueryParamTypes | None = None,
        raw_response: Literal[False] = False,
        select_path: Literal[""] = "",
        response_type: Literal[None] = None,
        headers: HeaderTypes | None = None,
        **kwargs,
    ) -> TimeseriesJsonResult: ...

    @overload
    async def get_last_datapoints_for_metric(
        self,
        resource_id: Annotated[
            StrictStr, Field(description="Uniquely identifies a resource.")
        ],
        metric: Annotated[
            StrictStr, Field(description="Identifies the times series metric.")
        ],
        *,
        query: GetLastDatapointsForMetricQuery | QueryParamTypes | None = None,
        raw_response: Literal[False] = False,
        select_path: Literal[""] = "",
        response_type: T,
        headers: HeaderTypes | None = None,
        **kwargs,
    ) -> T: ...

    @overload
    async def get_last_datapoints_for_metric(
        self,
        resource_id: Annotated[
            StrictStr, Field(description="Uniquely identifies a resource.")
        ],
        metric: Annotated[
            StrictStr, Field(description="Identifies the times series metric.")
        ],
        *,
        query: GetLastDatapointsForMetricQuery | QueryParamTypes | None = None,
        raw_response: Literal[True],
        select_path: Literal["_not_used_"] = "_not_used_",
        response_type: Literal[None] = None,  # not used
        headers: HeaderTypes | None = None,
        **kwargs,
    ) -> Response: ...

    @overload
    async def get_last_datapoints_for_metric(
        self,
        resource_id: Annotated[
            StrictStr, Field(description="Uniquely identifies a resource.")
        ],
        metric: Annotated[
            StrictStr, Field(description="Identifies the times series metric.")
        ],
        *,
        query: GetLastDatapointsForMetricQuery | QueryParamTypes | None = None,
        raw_response: Literal[False] = False,
        select_path: str,
        response_type: Literal[None] = None,
        headers: HeaderTypes | None = None,
        **kwargs,
    ) -> Model: ...

    @overload
    async def get_last_datapoints_for_metric(
        self,
        resource_id: Annotated[
            StrictStr, Field(description="Uniquely identifies a resource.")
        ],
        metric: Annotated[
            StrictStr, Field(description="Identifies the times series metric.")
        ],
        *,
        query: GetLastDatapointsForMetricQuery | QueryParamTypes | None = None,
        raw_response: Literal[False] = False,
        select_path: str,
        response_type: T,
        headers: HeaderTypes | None = None,
        **kwargs,
    ) -> T: ...

    async def get_last_datapoints_for_metric(
        self,
        resource_id: Annotated[
            StrictStr, Field(description="Uniquely identifies a resource.")
        ],
        metric: Annotated[
            StrictStr, Field(description="Identifies the times series metric.")
        ],
        *,
        query: GetLastDatapointsForMetricQuery | QueryParamTypes | None = None,
        raw_response: StrictBool = False,
        select_path: str = "",
        response_type: T | None = None,
        headers: HeaderTypes | None = None,
        **kwargs,
    ) -> TimeseriesJsonResult | T | Response | Model:
        """Get Last Unaggregated Values For A Series.

        Query the time series storage for the latest n datapoints for a particular metric from a resource.
        :param resource_id: Uniquely identifies a resource. (required)
        :type resource_id: str
        :param metric: Identifies the times series metric. (required)
        :type metric: str
        :param query: URL Query parameters.
        :type query: GetLastDatapointsForMetricQuery | QueryParamTypes, optional
        :param query['limit'] (dict) <br> query.limit (Query) : max number of values to retrieve
        :type query['limit']: int
        :param query['until'] (dict) <br> query.until (Query) : Specifies the upper bound of the time period. If not specified, a period of 7 days after `from` (or before the request was received) will be queried
        :type query['until']: GetMetricSeriesFromParameter
        :param raw_response: If true, return the http Response object instead of returning an api model object, or throwing an ApiError.
        :param select_path: Denotes the json path applied to the response object before returning it.
                Set it to the empty string `""` to receive the full response object.
        :param response_type: If specified, the response is parsed into an instance of the specified type.
        :param headers: Header parameters for this request
        :type headers: dict, optional
        :param `**kwargs`: Additional parameters passed on to the http client.
            See below.
        :Keyword Arguments:
            * timeout: a single numeric timeout in seconds,
                or a tuple of _connect_, _read_, _write_ and _pool_ timeouts.
            * stream: if true, the response will be in streaming mode
            * cookies
            * extensions
            * auth
            * follow_redirects: bool

        :return: Returns the result object if the http request succeeded with status code '2XX'.
        :raises APIError: If the http request has a status code different from `2XX`. This
            object wraps both the http Response and any parsed data.
        """

        should_validate = (
            MODELS_AVAILABLE and self.api_client.config.client_side_validation
        )

        # path parameters
        path_params: Dict[str, str] = {
            "resourceId": str(resource_id),
            "metric": str(metric),
        }

        ## named body parameters
        body_args: Dict[str, Any] = {}

        # query parameters
        if query is not None and should_validate:
            query = TypeAdapter(GetLastDatapointsForMetricQuery).validate_python(query)

        response_types_map: Dict[str, Any] = (
            {"2XX": response_type}
            if response_type is not None
            else {
                "200": TimeseriesJsonResult if not select_path else Model,
            }
        )
        non_200_response_types_map: Dict[str, Any] = {
            "400": ErrorResponse,
        }
        response_types_map.update(non_200_response_types_map)

        ## peform request
        return await self.api_client.request(
            method="GET",
            resource_path="/data/v1/series/{resourceId}/{metric}/last",
            path_params=path_params,
            params=query,
            **body_args,
            headers=headers,
            **kwargs,
            response_type=response_types_map,
            select_path=select_path,
            raw_response=raw_response,
        )

    @overload
    async def get_last_metric(
        self,
        resource_id: Annotated[
            StrictStr, Field(description="Uniquely identifies a resource.")
        ],
        metric: Annotated[
            StrictStr, Field(description="Identifies the times series metric.")
        ],
        *,
        query: GetLastMetricQuery | QueryParamTypes | None = None,
        raw_response: Literal[False] = False,
        select_path: Literal[""] = "",
        response_type: Literal[None] = None,
        headers: HeaderTypes | None = None,
        **kwargs,
    ) -> LatestMeasurement: ...

    @overload
    async def get_last_metric(
        self,
        resource_id: Annotated[
            StrictStr, Field(description="Uniquely identifies a resource.")
        ],
        metric: Annotated[
            StrictStr, Field(description="Identifies the times series metric.")
        ],
        *,
        query: GetLastMetricQuery | QueryParamTypes | None = None,
        raw_response: Literal[False] = False,
        select_path: Literal[""] = "",
        response_type: T,
        headers: HeaderTypes | None = None,
        **kwargs,
    ) -> T: ...

    @overload
    async def get_last_metric(
        self,
        resource_id: Annotated[
            StrictStr, Field(description="Uniquely identifies a resource.")
        ],
        metric: Annotated[
            StrictStr, Field(description="Identifies the times series metric.")
        ],
        *,
        query: GetLastMetricQuery | QueryParamTypes | None = None,
        raw_response: Literal[True],
        select_path: Literal["_not_used_"] = "_not_used_",
        response_type: Literal[None] = None,  # not used
        headers: HeaderTypes | None = None,
        **kwargs,
    ) -> Response: ...

    @overload
    async def get_last_metric(
        self,
        resource_id: Annotated[
            StrictStr, Field(description="Uniquely identifies a resource.")
        ],
        metric: Annotated[
            StrictStr, Field(description="Identifies the times series metric.")
        ],
        *,
        query: GetLastMetricQuery | QueryParamTypes | None = None,
        raw_response: Literal[False] = False,
        select_path: str,
        response_type: Literal[None] = None,
        headers: HeaderTypes | None = None,
        **kwargs,
    ) -> Model: ...

    @overload
    async def get_last_metric(
        self,
        resource_id: Annotated[
            StrictStr, Field(description="Uniquely identifies a resource.")
        ],
        metric: Annotated[
            StrictStr, Field(description="Identifies the times series metric.")
        ],
        *,
        query: GetLastMetricQuery | QueryParamTypes | None = None,
        raw_response: Literal[False] = False,
        select_path: str,
        response_type: T,
        headers: HeaderTypes | None = None,
        **kwargs,
    ) -> T: ...

    async def get_last_metric(
        self,
        resource_id: Annotated[
            StrictStr, Field(description="Uniquely identifies a resource.")
        ],
        metric: Annotated[
            StrictStr, Field(description="Identifies the times series metric.")
        ],
        *,
        query: GetLastMetricQuery | QueryParamTypes | None = None,
        raw_response: StrictBool = False,
        select_path: str = "",
        response_type: T | None = None,
        headers: HeaderTypes | None = None,
        **kwargs,
    ) -> LatestMeasurement | T | Response | Model:
        """Get Latest Value For A Series.

        Retrieves the latest value of a time series.
        :param resource_id: Uniquely identifies a resource. (required)
        :type resource_id: str
        :param metric: Identifies the times series metric. (required)
        :type metric: str
        :param query: URL Query parameters.
        :type query: GetLastMetricQuery | QueryParamTypes, optional
        :param raw_response: If true, return the http Response object instead of returning an api model object, or throwing an ApiError.
        :param select_path: Denotes the json path applied to the response object before returning it.
                Set it to the empty string `""` to receive the full response object.
        :param response_type: If specified, the response is parsed into an instance of the specified type.
        :param headers: Header parameters for this request
        :type headers: dict, optional
        :param `**kwargs`: Additional parameters passed on to the http client.
            See below.
        :Keyword Arguments:
            * timeout: a single numeric timeout in seconds,
                or a tuple of _connect_, _read_, _write_ and _pool_ timeouts.
            * stream: if true, the response will be in streaming mode
            * cookies
            * extensions
            * auth
            * follow_redirects: bool

        :return: Returns the result object if the http request succeeded with status code '2XX'.
        :raises APIError: If the http request has a status code different from `2XX`. This
            object wraps both the http Response and any parsed data.
        """

        should_validate = (
            MODELS_AVAILABLE and self.api_client.config.client_side_validation
        )

        # path parameters
        path_params: Dict[str, str] = {
            "resourceId": str(resource_id),
            "metric": str(metric),
        }

        ## named body parameters
        body_args: Dict[str, Any] = {}

        # query parameters
        if query is not None and should_validate:
            query = TypeAdapter(GetLastMetricQuery).validate_python(query)

        response_types_map: Dict[str, Any] = (
            {"2XX": response_type}
            if response_type is not None
            else {
                "200": LatestMeasurement if not select_path else Model,
            }
        )
        non_200_response_types_map: Dict[str, Any] = {
            "404": ErrorResponse,
        }
        response_types_map.update(non_200_response_types_map)

        ## peform request
        return await self.api_client.request(
            method="GET",
            resource_path="/data/v1/series/{resourceId}/{metric}/latest",
            path_params=path_params,
            params=query,
            **body_args,
            headers=headers,
            **kwargs,
            response_type=response_types_map,
            select_path=select_path,
            raw_response=raw_response,
        )

    @overload
    async def get_metric_series(
        self,
        resource_id: Annotated[
            StrictStr, Field(description="Uniquely identifies a resource.")
        ],
        metric: Annotated[
            StrictStr, Field(description="Identifies the times series metric.")
        ],
        *,
        query: GetMetricSeriesQuery | QueryParamTypes | None = None,
        raw_response: Literal[False] = False,
        select_path: Literal[""] = "",
        response_type: Literal[None] = None,
        headers: HeaderTypes | None = None,
        **kwargs,
    ) -> TimeseriesJsonResult: ...

    @overload
    async def get_metric_series(
        self,
        resource_id: Annotated[
            StrictStr, Field(description="Uniquely identifies a resource.")
        ],
        metric: Annotated[
            StrictStr, Field(description="Identifies the times series metric.")
        ],
        *,
        query: GetMetricSeriesQuery | QueryParamTypes | None = None,
        raw_response: Literal[False] = False,
        select_path: Literal[""] = "",
        response_type: T,
        headers: HeaderTypes | None = None,
        **kwargs,
    ) -> T: ...

    @overload
    async def get_metric_series(
        self,
        resource_id: Annotated[
            StrictStr, Field(description="Uniquely identifies a resource.")
        ],
        metric: Annotated[
            StrictStr, Field(description="Identifies the times series metric.")
        ],
        *,
        query: GetMetricSeriesQuery | QueryParamTypes | None = None,
        raw_response: Literal[True],
        select_path: Literal["_not_used_"] = "_not_used_",
        response_type: Literal[None] = None,  # not used
        headers: HeaderTypes | None = None,
        **kwargs,
    ) -> Response: ...

    @overload
    async def get_metric_series(
        self,
        resource_id: Annotated[
            StrictStr, Field(description="Uniquely identifies a resource.")
        ],
        metric: Annotated[
            StrictStr, Field(description="Identifies the times series metric.")
        ],
        *,
        query: GetMetricSeriesQuery | QueryParamTypes | None = None,
        raw_response: Literal[False] = False,
        select_path: str,
        response_type: Literal[None] = None,
        headers: HeaderTypes | None = None,
        **kwargs,
    ) -> Model: ...

    @overload
    async def get_metric_series(
        self,
        resource_id: Annotated[
            StrictStr, Field(description="Uniquely identifies a resource.")
        ],
        metric: Annotated[
            StrictStr, Field(description="Identifies the times series metric.")
        ],
        *,
        query: GetMetricSeriesQuery | QueryParamTypes | None = None,
        raw_response: Literal[False] = False,
        select_path: str,
        response_type: T,
        headers: HeaderTypes | None = None,
        **kwargs,
    ) -> T: ...

    async def get_metric_series(
        self,
        resource_id: Annotated[
            StrictStr, Field(description="Uniquely identifies a resource.")
        ],
        metric: Annotated[
            StrictStr, Field(description="Identifies the times series metric.")
        ],
        *,
        query: GetMetricSeriesQuery | QueryParamTypes | None = None,
        raw_response: StrictBool = False,
        select_path: str = "",
        response_type: T | None = None,
        headers: HeaderTypes | None = None,
        **kwargs,
    ) -> TimeseriesJsonResult | T | Response | Model:
        """Query Series.

        Queries a single timeseries. Depending on the `grouping` query parameter, data will be aggregated (if `grouping` is specified) or not. If data will be aggregated, you must specify one (through `aggregate` parameter) or more (through `aggregates` parameter) aggregation function(s).Optional order parameter applies sorting order to the result.
        :param resource_id: Uniquely identifies a resource. (required)
        :type resource_id: str
        :param metric: Identifies the times series metric. (required)
        :type metric: str
        :param query: URL Query parameters.
        :type query: GetMetricSeriesQuery | QueryParamTypes, optional
        :param query['from'] (dict) <br> query.var_from (Query) : Specifies the lower bound of the time period. If not specified, a period of 7 days before `until` (or before the request was received) will be queried.
        :type query['from']: GetMetricSeriesFromParameter
        :param query['until'] (dict) <br> query.until (Query) : Specifies the upper bound of the time period. If not specified, a period of 7 days after `from` (or before the request was received) will be queried
        :type query['until']: GetMetricSeriesFromParameter
        :param query['aggregate'] (dict) <br> query.aggregate (Query) : Specifies the aggregation function to use
        :type query['aggregate']: Aggregate
        :param query['aggregates'] (dict) <br> query.aggregates (Query) : comma-separated list of aggregation functions
        :type query['aggregates']: str
        :param query['grouping'] (dict) <br> query.grouping (Query) : time period over which timeseries data must be aggregates
        :type query['grouping']: Grouping
        :param query['order'] (dict) <br> query.order (Query) : sort order
        :type query['order']: Order
        :param raw_response: If true, return the http Response object instead of returning an api model object, or throwing an ApiError.
        :param select_path: Denotes the json path applied to the response object before returning it.
                Set it to the empty string `""` to receive the full response object.
        :param response_type: If specified, the response is parsed into an instance of the specified type.
        :param headers: Header parameters for this request
        :type headers: dict, optional
        :param `**kwargs`: Additional parameters passed on to the http client.
            See below.
        :Keyword Arguments:
            * timeout: a single numeric timeout in seconds,
                or a tuple of _connect_, _read_, _write_ and _pool_ timeouts.
            * stream: if true, the response will be in streaming mode
            * cookies
            * extensions
            * auth
            * follow_redirects: bool

        :return: Returns the result object if the http request succeeded with status code '2XX'.
        :raises APIError: If the http request has a status code different from `2XX`. This
            object wraps both the http Response and any parsed data.
        """

        should_validate = (
            MODELS_AVAILABLE and self.api_client.config.client_side_validation
        )

        # path parameters
        path_params: Dict[str, str] = {
            "resourceId": str(resource_id),
            "metric": str(metric),
        }

        ## named body parameters
        body_args: Dict[str, Any] = {}

        # query parameters
        if query is not None and should_validate:
            query = TypeAdapter(GetMetricSeriesQuery).validate_python(query)

        response_types_map: Dict[str, Any] = (
            {"2XX": response_type}
            if response_type is not None
            else {
                "200": TimeseriesJsonResult if not select_path else Model,
            }
        )
        non_200_response_types_map: Dict[str, Any] = {
            "400": ErrorResponse,
        }
        response_types_map.update(non_200_response_types_map)

        ## peform request
        return await self.api_client.request(
            method="GET",
            resource_path="/data/v1/series/{resourceId}/{metric}",
            path_params=path_params,
            params=query,
            **body_args,
            headers=headers,
            **kwargs,
            response_type=response_types_map,
            select_path=select_path,
            raw_response=raw_response,
        )

    @overload
    async def get_series(
        self,
        resource_id: Annotated[
            StrictStr, Field(description="Uniquely identifies a resource.")
        ],
        *,
        query: GetSeriesQuery | QueryParamTypes | None = None,
        raw_response: Literal[False] = False,
        select_path: Literal[""] = "",
        response_type: Literal[None] = None,
        headers: HeaderTypes | None = None,
        **kwargs,
    ) -> List[GetSeries200ResponseInner]: ...

    @overload
    async def get_series(
        self,
        resource_id: Annotated[
            StrictStr, Field(description="Uniquely identifies a resource.")
        ],
        *,
        query: GetSeriesQuery | QueryParamTypes | None = None,
        raw_response: Literal[False] = False,
        select_path: Literal[""] = "",
        response_type: T,
        headers: HeaderTypes | None = None,
        **kwargs,
    ) -> T: ...

    @overload
    async def get_series(
        self,
        resource_id: Annotated[
            StrictStr, Field(description="Uniquely identifies a resource.")
        ],
        *,
        query: GetSeriesQuery | QueryParamTypes | None = None,
        raw_response: Literal[True],
        select_path: Literal["_not_used_"] = "_not_used_",
        response_type: Literal[None] = None,  # not used
        headers: HeaderTypes | None = None,
        **kwargs,
    ) -> Response: ...

    @overload
    async def get_series(
        self,
        resource_id: Annotated[
            StrictStr, Field(description="Uniquely identifies a resource.")
        ],
        *,
        query: GetSeriesQuery | QueryParamTypes | None = None,
        raw_response: Literal[False] = False,
        select_path: str,
        response_type: Literal[None] = None,
        headers: HeaderTypes | None = None,
        **kwargs,
    ) -> Model: ...

    @overload
    async def get_series(
        self,
        resource_id: Annotated[
            StrictStr, Field(description="Uniquely identifies a resource.")
        ],
        *,
        query: GetSeriesQuery | QueryParamTypes | None = None,
        raw_response: Literal[False] = False,
        select_path: str,
        response_type: T,
        headers: HeaderTypes | None = None,
        **kwargs,
    ) -> T: ...

    async def get_series(
        self,
        resource_id: Annotated[
            StrictStr, Field(description="Uniquely identifies a resource.")
        ],
        *,
        query: GetSeriesQuery | QueryParamTypes | None = None,
        raw_response: StrictBool = False,
        select_path: str = "",
        response_type: T | None = None,
        headers: HeaderTypes | None = None,
        **kwargs,
    ) -> List[GetSeries200ResponseInner] | T | Response | Model:
        """Get Series Overview.

        Lists the existing timeseries for the given resource.
        :param resource_id: Uniquely identifies a resource. (required)
        :type resource_id: str
        :param query: URL Query parameters.
        :type query: GetSeriesQuery | QueryParamTypes, optional
        :param raw_response: If true, return the http Response object instead of returning an api model object, or throwing an ApiError.
        :param select_path: Denotes the json path applied to the response object before returning it.
                Set it to the empty string `""` to receive the full response object.
        :param response_type: If specified, the response is parsed into an instance of the specified type.
        :param headers: Header parameters for this request
        :type headers: dict, optional
        :param `**kwargs`: Additional parameters passed on to the http client.
            See below.
        :Keyword Arguments:
            * timeout: a single numeric timeout in seconds,
                or a tuple of _connect_, _read_, _write_ and _pool_ timeouts.
            * stream: if true, the response will be in streaming mode
            * cookies
            * extensions
            * auth
            * follow_redirects: bool

        :return: Returns the result object if the http request succeeded with status code '2XX'.
        :raises APIError: If the http request has a status code different from `2XX`. This
            object wraps both the http Response and any parsed data.
        """

        should_validate = (
            MODELS_AVAILABLE and self.api_client.config.client_side_validation
        )

        # path parameters
        path_params: Dict[str, str] = {
            "resourceId": str(resource_id),
        }

        ## named body parameters
        body_args: Dict[str, Any] = {}

        # query parameters
        if query is not None and should_validate:
            query = TypeAdapter(GetSeriesQuery).validate_python(query)

        response_types_map: Dict[str, Any] = (
            {"2XX": response_type}
            if response_type is not None
            else {
                "200": List[GetSeries200ResponseInner] if not select_path else Model,
            }
        )
        non_200_response_types_map: Dict[str, Any] = {}
        response_types_map.update(non_200_response_types_map)

        ## peform request
        return await self.api_client.request(
            method="GET",
            resource_path="/data/v1/series/{resourceId}",
            path_params=path_params,
            params=query,
            **body_args,
            headers=headers,
            **kwargs,
            response_type=response_types_map,
            select_path=select_path,
            raw_response=raw_response,
        )

    @overload
    async def query_time_series(
        self,
        *,
        json: QueryTimeSeriesRequest,
        query: QueryTimeSeriesQuery | QueryParamTypes | None = None,
        raw_response: Literal[False] = False,
        select_path: Literal[""] = "",
        response_type: Literal[None] = None,
        headers: HeaderTypes | None = None,
        **kwargs,
    ) -> QueryTimeSeries200Response: ...

    @overload
    async def query_time_series(
        self,
        *,
        json: QueryTimeSeriesRequest,
        query: QueryTimeSeriesQuery | QueryParamTypes | None = None,
        raw_response: Literal[False] = False,
        select_path: Literal[""] = "",
        response_type: T,
        headers: HeaderTypes | None = None,
        **kwargs,
    ) -> T: ...

    @overload
    async def query_time_series(
        self,
        *,
        json: QueryTimeSeriesRequest,
        query: QueryTimeSeriesQuery | QueryParamTypes | None = None,
        raw_response: Literal[True],
        select_path: Literal["_not_used_"] = "_not_used_",
        response_type: Literal[None] = None,  # not used
        headers: HeaderTypes | None = None,
        **kwargs,
    ) -> Response: ...

    @overload
    async def query_time_series(
        self,
        *,
        json: QueryTimeSeriesRequest,
        query: QueryTimeSeriesQuery | QueryParamTypes | None = None,
        raw_response: Literal[False] = False,
        select_path: str,
        response_type: Literal[None] = None,
        headers: HeaderTypes | None = None,
        **kwargs,
    ) -> Model: ...

    @overload
    async def query_time_series(
        self,
        *,
        json: QueryTimeSeriesRequest,
        query: QueryTimeSeriesQuery | QueryParamTypes | None = None,
        raw_response: Literal[False] = False,
        select_path: str,
        response_type: T,
        headers: HeaderTypes | None = None,
        **kwargs,
    ) -> T: ...

    async def query_time_series(
        self,
        *,
        json: QueryTimeSeriesRequest,
        query: QueryTimeSeriesQuery | QueryParamTypes | None = None,
        raw_response: StrictBool = False,
        select_path: str = "",
        response_type: T | None = None,
        headers: HeaderTypes | None = None,
        **kwargs,
    ) -> QueryTimeSeries200Response | T | Response | Model:
        """Query Series Data.

        Executes an ad-hoc timeseries query.
        :param json: The json request body.
        :type json: QueryTimeSeriesRequest, optional
        :param query: URL Query parameters.
        :type query: QueryTimeSeriesQuery | QueryParamTypes, optional
        :param raw_response: If true, return the http Response object instead of returning an api model object, or throwing an ApiError.
        :param select_path: Denotes the json path applied to the response object before returning it.
                Set it to the empty string `""` to receive the full response object.
        :param response_type: If specified, the response is parsed into an instance of the specified type.
        :param headers: Header parameters for this request
        :type headers: dict, optional
        :param `**kwargs`: Additional parameters passed on to the http client.
            See below.
        :Keyword Arguments:
            * timeout: a single numeric timeout in seconds,
                or a tuple of _connect_, _read_, _write_ and _pool_ timeouts.
            * stream: if true, the response will be in streaming mode
            * cookies
            * extensions
            * auth
            * follow_redirects: bool

        :return: Returns the result object if the http request succeeded with status code '2XX'.
        :raises APIError: If the http request has a status code different from `2XX`. This
            object wraps both the http Response and any parsed data.
        """

        should_validate = (
            MODELS_AVAILABLE and self.api_client.config.client_side_validation
        )

        # path parameters
        path_params: Dict[str, str] = {}

        ## named body parameters
        body_args: Dict[str, Any] = {}
        if json is not None and should_validate:
            body_adapter = TypeAdapter(QueryTimeSeriesRequest)
            json = body_adapter.validate_python(json)  # type: ignore # https://github.com/pydantic/pydantic/discussions/7094
        body_args["json"] = json

        # query parameters
        if query is not None and should_validate:
            query = TypeAdapter(QueryTimeSeriesQuery).validate_python(query)

        response_types_map: Dict[str, Any] = (
            {"2XX": response_type}
            if response_type is not None
            else {
                "200": QueryTimeSeries200Response if not select_path else Model,
            }
        )
        non_200_response_types_map: Dict[str, Any] = {
            "400": ErrorResponse,
        }
        response_types_map.update(non_200_response_types_map)

        ## peform request
        return await self.api_client.request(
            method="POST",
            resource_path="/data/v1/series/query",
            path_params=path_params,
            params=query,
            **body_args,
            headers=headers,
            **kwargs,
            response_type=response_types_map,
            select_path=select_path,
            raw_response=raw_response,
        )
