# coding: utf-8
"""Waylay Broker api tests.

This code was generated from the OpenAPI documentation of 'Waylay Broker'

Generated by OpenAPI Generator (https://openapi-generator.tech)

Do not edit the class manually.
"""

import json
import re
from importlib.util import find_spec
from typing import Union
from urllib.parse import quote

import pytest
from pytest_httpx import HTTPXMock
from typeguard import check_type
from waylay.sdk import ApiClient, WaylayClient
from waylay.sdk.api._models import Model
from waylay.services.data.api import EventsApi
from waylay.services.data.service import DataService

from ..types.delete_messages200_response_stub import DeleteMessages200ResponseStub
from ..types.delete_series_from_parameter_stub import DeleteSeriesFromParameterStub
from ..types.post_series_for_resource_request_stub import (
    PostSeriesForResourceRequestStub,
)
from ..types.post_series_request_stub import PostSeriesRequestStub
from ..types.publish_event_response_stub import PublishEventResponseStub
from ..types.publish_resource_event_response_stub import (
    PublishResourceEventResponseStub,
)
from ..types.timestamped_resource_event_stub import TimestampedResourceEventStub
from ..types.ttl_duration_stub import TTLDurationStub

MODELS_AVAILABLE = (
    True if find_spec("waylay.services.data.models") is not None else False
)

if MODELS_AVAILABLE:
    from waylay.services.data.models import (
        DeleteMessages200Response,
        PublishEventResponse,
        PublishResourceEventResponse,
        TimestampedResourceEvent,
    )
    from waylay.services.data.queries.events_api import (
        PostSeriesForResourceQuery,
        PostSeriesQuery,
        RemoveQuery,
    )


# some mappings that are needed for some <example> interpolations
null, true, false = None, True, False


@pytest.fixture
def events_api(waylay_api_client: ApiClient) -> EventsApi:
    return EventsApi(waylay_api_client)


def test_registered(waylay_client: WaylayClient):
    """Test that EventsApi api is registered in the sdk client."""
    assert isinstance(waylay_client.data.events, EventsApi)


def _post_series_set_mock_response(httpx_mock: HTTPXMock, gateway_url: str):
    mock_response = PublishEventResponseStub.create_json()
    httpx_mock_kwargs = {
        "method": "POST",
        "url": re.compile(f"^{gateway_url}/data/v1/events(\\?.*)?"),
        "content": json.dumps(mock_response, default=str),
        "status_code": 200,
    }
    httpx_mock.add_response(**httpx_mock_kwargs)


@pytest.mark.asyncio
@pytest.mark.skipif(not MODELS_AVAILABLE, reason="Types not installed.")
async def test_post_series(
    service: DataService, gateway_url: str, httpx_mock: HTTPXMock
):
    """Test case for post_series
    Post Events
    """
    # set path params
    kwargs = {
        # optionally use PostSeriesQuery to validate and reuse parameters
        "query": PostSeriesQuery(
            forward=True,
            store=True,
            ttl=TTLDurationStub.create_json(),
        ),
        "json": PostSeriesRequestStub.create_instance(),
    }
    _post_series_set_mock_response(httpx_mock, gateway_url)
    resp = await service.events.post_series(**kwargs)
    check_type(resp, Union[PublishEventResponse,])


@pytest.mark.asyncio
@pytest.mark.skipif(MODELS_AVAILABLE, reason="Types installed.")
async def test_post_series_without_types(
    service: DataService, gateway_url: str, httpx_mock: HTTPXMock
):
    """Test case for post_series with models not installed
    Post Events
    """
    # set path params
    kwargs = {
        "query": {
            "forward": True,
            "store": True,
            "ttl": TTLDurationStub.create_json(),
        },
        "json": PostSeriesRequestStub.create_json(),
    }
    _post_series_set_mock_response(httpx_mock, gateway_url)
    resp = await service.events.post_series(**kwargs)
    check_type(resp, Model)


def _post_series_for_resource_set_mock_response(
    httpx_mock: HTTPXMock, gateway_url: str, resourceId: str
):
    mock_response = PublishResourceEventResponseStub.create_json()
    httpx_mock_kwargs = {
        "method": "POST",
        "url": re.compile(f"^{gateway_url}/data/v1/events/{resourceId}(\\?.*)?"),
        "content": json.dumps(mock_response, default=str),
        "status_code": 200,
    }
    httpx_mock.add_response(**httpx_mock_kwargs)


@pytest.mark.asyncio
@pytest.mark.skipif(not MODELS_AVAILABLE, reason="Types not installed.")
async def test_post_series_for_resource(
    service: DataService, gateway_url: str, httpx_mock: HTTPXMock
):
    """Test case for post_series_for_resource
    Post Events For Resource
    """
    # set path params
    resourceId = "resource_id_example"

    kwargs = {
        # optionally use PostSeriesForResourceQuery to validate and reuse parameters
        "query": PostSeriesForResourceQuery(
            forward=True,
            store=True,
            ttl=TTLDurationStub.create_json(),
        ),
        "json": PostSeriesForResourceRequestStub.create_instance(),
    }
    _post_series_for_resource_set_mock_response(
        httpx_mock, gateway_url, quote(str(resourceId))
    )
    resp = await service.events.post_series_for_resource(resourceId, **kwargs)
    check_type(resp, Union[PublishResourceEventResponse,])


@pytest.mark.asyncio
@pytest.mark.skipif(MODELS_AVAILABLE, reason="Types installed.")
async def test_post_series_for_resource_without_types(
    service: DataService, gateway_url: str, httpx_mock: HTTPXMock
):
    """Test case for post_series_for_resource with models not installed
    Post Events For Resource
    """
    # set path params
    resourceId = "resource_id_example"

    kwargs = {
        "query": {
            "forward": True,
            "store": True,
            "ttl": TTLDurationStub.create_json(),
        },
        "json": PostSeriesForResourceRequestStub.create_json(),
    }
    _post_series_for_resource_set_mock_response(
        httpx_mock, gateway_url, quote(str(resourceId))
    )
    resp = await service.events.post_series_for_resource(resourceId, **kwargs)
    check_type(resp, Model)


def _remove_set_mock_response(httpx_mock: HTTPXMock, gateway_url: str, resourceId: str):
    mock_response = DeleteMessages200ResponseStub.create_json()
    httpx_mock_kwargs = {
        "method": "DELETE",
        "url": re.compile(f"^{gateway_url}/data/v1/{resourceId}(\\?.*)?"),
        "content": json.dumps(mock_response, default=str),
        "status_code": 200,
    }
    httpx_mock.add_response(**httpx_mock_kwargs)


@pytest.mark.asyncio
@pytest.mark.skipif(not MODELS_AVAILABLE, reason="Types not installed.")
async def test_remove(service: DataService, gateway_url: str, httpx_mock: HTTPXMock):
    """Test case for remove
    Remove Data
    """
    # set path params
    resourceId = "resource_id_example"

    kwargs = {
        # optionally use RemoveQuery to validate and reuse parameters
        "query": RemoveQuery(
            var_from=DeleteSeriesFromParameterStub.create_json(),
            until=DeleteSeriesFromParameterStub.create_json(),
            onlytimeseries=False,
        ),
    }
    _remove_set_mock_response(httpx_mock, gateway_url, quote(str(resourceId)))
    resp = await service.events.remove(resourceId, **kwargs)
    check_type(resp, Union[DeleteMessages200Response,])


@pytest.mark.asyncio
@pytest.mark.skipif(MODELS_AVAILABLE, reason="Types installed.")
async def test_remove_without_types(
    service: DataService, gateway_url: str, httpx_mock: HTTPXMock
):
    """Test case for remove with models not installed
    Remove Data
    """
    # set path params
    resourceId = "resource_id_example"

    kwargs = {
        "query": {
            "from": DeleteSeriesFromParameterStub.create_json(),
            "until": DeleteSeriesFromParameterStub.create_json(),
            "onlytimeseries": False,
        },
    }
    _remove_set_mock_response(httpx_mock, gateway_url, quote(str(resourceId)))
    resp = await service.events.remove(resourceId, **kwargs)
    check_type(resp, Model)


def _stream_events_set_mock_response(
    httpx_mock: HTTPXMock, gateway_url: str, resourceId: str
):
    mock_response = TimestampedResourceEventStub.create_json()
    httpx_mock_kwargs = {
        "method": "GET",
        "url": re.compile(f"^{gateway_url}/data/v1/events/{resourceId}(\\?.*)?"),
        "content": json.dumps(mock_response, default=str),
        "status_code": 200,
    }
    httpx_mock.add_response(**httpx_mock_kwargs)


@pytest.mark.asyncio
@pytest.mark.skipif(not MODELS_AVAILABLE, reason="Types not installed.")
async def test_stream_events(
    service: DataService, gateway_url: str, httpx_mock: HTTPXMock
):
    """Test case for stream_events
    Stream Events For Resource
    """
    # set path params
    resourceId = "resource_id_example"

    kwargs = {}
    _stream_events_set_mock_response(httpx_mock, gateway_url, quote(str(resourceId)))
    resp = await service.events.stream_events(resourceId, **kwargs)
    check_type(resp, Union[TimestampedResourceEvent,])


@pytest.mark.asyncio
@pytest.mark.skipif(MODELS_AVAILABLE, reason="Types installed.")
async def test_stream_events_without_types(
    service: DataService, gateway_url: str, httpx_mock: HTTPXMock
):
    """Test case for stream_events with models not installed
    Stream Events For Resource
    """
    # set path params
    resourceId = "resource_id_example"

    kwargs = {}
    _stream_events_set_mock_response(httpx_mock, gateway_url, quote(str(resourceId)))
    resp = await service.events.stream_events(resourceId, **kwargs)
    check_type(resp, Model)
