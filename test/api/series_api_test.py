# coding: utf-8
"""Waylay Broker api tests.

This code was generated from the OpenAPI documentation of 'Waylay Broker'

Generated by OpenAPI Generator (https://openapi-generator.tech)

Do not edit the class manually.
"""

import json
import re
from importlib.util import find_spec
from typing import List
from urllib.parse import quote

import pytest
from pytest_httpx import HTTPXMock
from typeguard import check_type
from waylay.sdk import ApiClient, WaylayClient
from waylay.sdk.api._models import Model
from waylay.services.data.api import SeriesApi
from waylay.services.data.service import DataService

from ..types.delete_messages200_response_stub import DeleteMessages200ResponseStub
from ..types.delete_series_from_parameter_stub import DeleteSeriesFromParameterStub
from ..types.get_metric_series_from_parameter_stub import (
    GetMetricSeriesFromParameterStub,
)
from ..types.get_series200_response_inner_stub import GetSeries200ResponseInnerStub
from ..types.grouping_stub import GroupingStub
from ..types.latest_measurement_stub import LatestMeasurementStub
from ..types.query_time_series200_response_stub import QueryTimeSeries200ResponseStub
from ..types.query_time_series_request_stub import QueryTimeSeriesRequestStub
from ..types.timeseries_json_result_stub import TimeseriesJsonResultStub

MODELS_AVAILABLE = (
    True if find_spec("waylay.services.data.models") is not None else False
)

if MODELS_AVAILABLE:
    from waylay.services.data.models import (
        DeleteMessages200Response,
        GetSeries200ResponseInner,
        LatestMeasurement,
        QueryTimeSeries200Response,
        TimeseriesJsonResult,
    )
    from waylay.services.data.queries.series_api import (
        DeleteSeriesQuery,
        GetDatapointsForMetricRawQuery,
        GetLastDatapointsForMetricQuery,
        GetLastMetricQuery,
        GetMetricSeriesQuery,
        GetSeriesQuery,
    )


# some mappings that are needed for some <example> interpolations
null, true, false = None, True, False


@pytest.fixture
def series_api(waylay_api_client: ApiClient) -> SeriesApi:
    return SeriesApi(waylay_api_client)


def test_registered(waylay_client: WaylayClient):
    """Test that SeriesApi api is registered in the sdk client."""
    assert isinstance(waylay_client.data.series, SeriesApi)


def _delete_series_set_mock_response(
    httpx_mock: HTTPXMock, gateway_url: str, resourceId: str
):
    mock_response = DeleteMessages200ResponseStub.create_json()
    httpx_mock_kwargs = {
        "method": "DELETE",
        "url": re.compile(f"^{gateway_url}/data/v1/series/{resourceId}(\\?.*)?"),
        "content": json.dumps(mock_response, default=str),
        "status_code": 200,
    }
    httpx_mock.add_response(**httpx_mock_kwargs)


@pytest.mark.asyncio
@pytest.mark.skipif(not MODELS_AVAILABLE, reason="Types not installed.")
async def test_delete_series(
    service: DataService, gateway_url: str, httpx_mock: HTTPXMock
):
    """Test case for delete_series
    Delete Series
    """
    # set path params
    resourceId = "resource_id_example"

    kwargs = {
        # optionally use DeleteSeriesQuery to validate and reuse parameters
        "query": DeleteSeriesQuery(
            var_from=DeleteSeriesFromParameterStub.create_json(),
            until=DeleteSeriesFromParameterStub.create_json(),
            metrics=["temperature"],
        ),
    }
    _delete_series_set_mock_response(httpx_mock, gateway_url, quote(str(resourceId)))
    resp = await service.series.delete_series(resourceId, **kwargs)
    check_type(resp, DeleteMessages200Response)


@pytest.mark.asyncio
@pytest.mark.skipif(MODELS_AVAILABLE, reason="Types installed.")
async def test_delete_series_without_types(
    service: DataService, gateway_url: str, httpx_mock: HTTPXMock
):
    """Test case for delete_series with models not installed
    Delete Series
    """
    # set path params
    resourceId = "resource_id_example"

    kwargs = {
        "query": {
            "from": DeleteSeriesFromParameterStub.create_json(),
            "until": DeleteSeriesFromParameterStub.create_json(),
            "Metrics": ["temperature"],
        },
    }
    _delete_series_set_mock_response(httpx_mock, gateway_url, quote(str(resourceId)))
    resp = await service.series.delete_series(resourceId, **kwargs)
    check_type(resp, Model)


def _get_datapoints_for_metric_raw_set_mock_response(
    httpx_mock: HTTPXMock, gateway_url: str, resourceId: str, metric: str
):
    mock_response = TimeseriesJsonResultStub.create_json()
    httpx_mock_kwargs = {
        "method": "GET",
        "url": re.compile(
            f"^{gateway_url}/data/v1/series/{resourceId}/{metric}/raw(\\?.*)?"
        ),
        "content": json.dumps(mock_response, default=str),
        "status_code": 200,
    }
    httpx_mock.add_response(**httpx_mock_kwargs)


@pytest.mark.asyncio
@pytest.mark.skipif(not MODELS_AVAILABLE, reason="Types not installed.")
async def test_get_datapoints_for_metric_raw(
    service: DataService, gateway_url: str, httpx_mock: HTTPXMock
):
    """Test case for get_datapoints_for_metric_raw
    Get Unaggregated Values For A Series
    """
    # set path params
    resourceId = "resource_id_example"

    metric = "metric_example"

    kwargs = {
        # optionally use GetDatapointsForMetricRawQuery to validate and reuse parameters
        "query": GetDatapointsForMetricRawQuery(
            var_from=GetMetricSeriesFromParameterStub.create_json(),
            until=GetMetricSeriesFromParameterStub.create_json(),
            limit=1,
            order="ascending",
            return_ingestion_timestamp=False,
        ),
    }
    _get_datapoints_for_metric_raw_set_mock_response(
        httpx_mock, gateway_url, quote(str(resourceId)), quote(str(metric))
    )
    resp = await service.series.get_datapoints_for_metric_raw(
        resourceId, metric, **kwargs
    )
    check_type(resp, TimeseriesJsonResult)


@pytest.mark.asyncio
@pytest.mark.skipif(MODELS_AVAILABLE, reason="Types installed.")
async def test_get_datapoints_for_metric_raw_without_types(
    service: DataService, gateway_url: str, httpx_mock: HTTPXMock
):
    """Test case for get_datapoints_for_metric_raw with models not installed
    Get Unaggregated Values For A Series
    """
    # set path params
    resourceId = "resource_id_example"

    metric = "metric_example"

    kwargs = {
        "query": {
            "from": GetMetricSeriesFromParameterStub.create_json(),
            "until": GetMetricSeriesFromParameterStub.create_json(),
            "limit": 1,
            "order": "ascending",
            "returnIngestionTimestamp": False,
        },
    }
    _get_datapoints_for_metric_raw_set_mock_response(
        httpx_mock, gateway_url, quote(str(resourceId)), quote(str(metric))
    )
    resp = await service.series.get_datapoints_for_metric_raw(
        resourceId, metric, **kwargs
    )
    check_type(resp, Model)


def _get_last_datapoints_for_metric_set_mock_response(
    httpx_mock: HTTPXMock, gateway_url: str, resourceId: str, metric: str
):
    mock_response = TimeseriesJsonResultStub.create_json()
    httpx_mock_kwargs = {
        "method": "GET",
        "url": re.compile(
            f"^{gateway_url}/data/v1/series/{resourceId}/{metric}/last(\\?.*)?"
        ),
        "content": json.dumps(mock_response, default=str),
        "status_code": 200,
    }
    httpx_mock.add_response(**httpx_mock_kwargs)


@pytest.mark.asyncio
@pytest.mark.skipif(not MODELS_AVAILABLE, reason="Types not installed.")
async def test_get_last_datapoints_for_metric(
    service: DataService, gateway_url: str, httpx_mock: HTTPXMock
):
    """Test case for get_last_datapoints_for_metric
    Get Last Unaggregated Values For A Series
    """
    # set path params
    resourceId = "resource_id_example"

    metric = "metric_example"

    kwargs = {
        # optionally use GetLastDatapointsForMetricQuery to validate and reuse parameters
        "query": GetLastDatapointsForMetricQuery(
            limit=1,
            until=GetMetricSeriesFromParameterStub.create_json(),
            return_ingestion_timestamp=False,
        ),
    }
    _get_last_datapoints_for_metric_set_mock_response(
        httpx_mock, gateway_url, quote(str(resourceId)), quote(str(metric))
    )
    resp = await service.series.get_last_datapoints_for_metric(
        resourceId, metric, **kwargs
    )
    check_type(resp, TimeseriesJsonResult)


@pytest.mark.asyncio
@pytest.mark.skipif(MODELS_AVAILABLE, reason="Types installed.")
async def test_get_last_datapoints_for_metric_without_types(
    service: DataService, gateway_url: str, httpx_mock: HTTPXMock
):
    """Test case for get_last_datapoints_for_metric with models not installed
    Get Last Unaggregated Values For A Series
    """
    # set path params
    resourceId = "resource_id_example"

    metric = "metric_example"

    kwargs = {
        "query": {
            "limit": 1,
            "until": GetMetricSeriesFromParameterStub.create_json(),
            "returnIngestionTimestamp": False,
        },
    }
    _get_last_datapoints_for_metric_set_mock_response(
        httpx_mock, gateway_url, quote(str(resourceId)), quote(str(metric))
    )
    resp = await service.series.get_last_datapoints_for_metric(
        resourceId, metric, **kwargs
    )
    check_type(resp, Model)


def _get_last_metric_set_mock_response(
    httpx_mock: HTTPXMock, gateway_url: str, resourceId: str, metric: str
):
    mock_response = LatestMeasurementStub.create_json()
    httpx_mock_kwargs = {
        "method": "GET",
        "url": re.compile(
            f"^{gateway_url}/data/v1/series/{resourceId}/{metric}/latest(\\?.*)?"
        ),
        "content": json.dumps(mock_response, default=str),
        "status_code": 200,
    }
    httpx_mock.add_response(**httpx_mock_kwargs)


@pytest.mark.asyncio
@pytest.mark.skipif(not MODELS_AVAILABLE, reason="Types not installed.")
async def test_get_last_metric(
    service: DataService, gateway_url: str, httpx_mock: HTTPXMock
):
    """Test case for get_last_metric
    Get Latest Value For A Series
    """
    # set path params
    resourceId = "resource_id_example"

    metric = "metric_example"

    kwargs = {
        # optionally use GetLastMetricQuery to validate and reuse parameters
        "query": GetLastMetricQuery(
            return_ingestion_timestamp=False,
        ),
    }
    _get_last_metric_set_mock_response(
        httpx_mock, gateway_url, quote(str(resourceId)), quote(str(metric))
    )
    resp = await service.series.get_last_metric(resourceId, metric, **kwargs)
    check_type(resp, LatestMeasurement)


@pytest.mark.asyncio
@pytest.mark.skipif(MODELS_AVAILABLE, reason="Types installed.")
async def test_get_last_metric_without_types(
    service: DataService, gateway_url: str, httpx_mock: HTTPXMock
):
    """Test case for get_last_metric with models not installed
    Get Latest Value For A Series
    """
    # set path params
    resourceId = "resource_id_example"

    metric = "metric_example"

    kwargs = {
        "query": {
            "returnIngestionTimestamp": False,
        },
    }
    _get_last_metric_set_mock_response(
        httpx_mock, gateway_url, quote(str(resourceId)), quote(str(metric))
    )
    resp = await service.series.get_last_metric(resourceId, metric, **kwargs)
    check_type(resp, Model)


def _get_metric_series_set_mock_response(
    httpx_mock: HTTPXMock, gateway_url: str, resourceId: str, metric: str
):
    mock_response = TimeseriesJsonResultStub.create_json()
    httpx_mock_kwargs = {
        "method": "GET",
        "url": re.compile(
            f"^{gateway_url}/data/v1/series/{resourceId}/{metric}(\\?.*)?"
        ),
        "content": json.dumps(mock_response, default=str),
        "status_code": 200,
    }
    httpx_mock.add_response(**httpx_mock_kwargs)


@pytest.mark.asyncio
@pytest.mark.skipif(not MODELS_AVAILABLE, reason="Types not installed.")
async def test_get_metric_series(
    service: DataService, gateway_url: str, httpx_mock: HTTPXMock
):
    """Test case for get_metric_series
    Query Series
    """
    # set path params
    resourceId = "resource_id_example"

    metric = "metric_example"

    kwargs = {
        # optionally use GetMetricSeriesQuery to validate and reuse parameters
        "query": GetMetricSeriesQuery(
            var_from=GetMetricSeriesFromParameterStub.create_json(),
            until=GetMetricSeriesFromParameterStub.create_json(),
            aggregate="min",
            aggregates="min,max",
            grouping=GroupingStub.create_json(),
            order="ascending",
            return_ingestion_timestamp=False,
        ),
    }
    _get_metric_series_set_mock_response(
        httpx_mock, gateway_url, quote(str(resourceId)), quote(str(metric))
    )
    resp = await service.series.get_metric_series(resourceId, metric, **kwargs)
    check_type(resp, TimeseriesJsonResult)


@pytest.mark.asyncio
@pytest.mark.skipif(MODELS_AVAILABLE, reason="Types installed.")
async def test_get_metric_series_without_types(
    service: DataService, gateway_url: str, httpx_mock: HTTPXMock
):
    """Test case for get_metric_series with models not installed
    Query Series
    """
    # set path params
    resourceId = "resource_id_example"

    metric = "metric_example"

    kwargs = {
        "query": {
            "from": GetMetricSeriesFromParameterStub.create_json(),
            "until": GetMetricSeriesFromParameterStub.create_json(),
            "aggregate": "min",
            "aggregates": "min,max",
            "grouping": GroupingStub.create_json(),
            "order": "ascending",
            "returnIngestionTimestamp": False,
        },
    }
    _get_metric_series_set_mock_response(
        httpx_mock, gateway_url, quote(str(resourceId)), quote(str(metric))
    )
    resp = await service.series.get_metric_series(resourceId, metric, **kwargs)
    check_type(resp, Model)


def _get_series_set_mock_response(
    httpx_mock: HTTPXMock, gateway_url: str, resourceId: str
):
    mock_response = [GetSeries200ResponseInnerStub.create_json()]
    httpx_mock_kwargs = {
        "method": "GET",
        "url": re.compile(f"^{gateway_url}/data/v1/series/{resourceId}(\\?.*)?"),
        "content": json.dumps(mock_response, default=str),
        "status_code": 200,
    }
    httpx_mock.add_response(**httpx_mock_kwargs)


@pytest.mark.asyncio
@pytest.mark.skipif(not MODELS_AVAILABLE, reason="Types not installed.")
async def test_get_series(
    service: DataService, gateway_url: str, httpx_mock: HTTPXMock
):
    """Test case for get_series
    Get Series Overview
    """
    # set path params
    resourceId = "resource_id_example"

    kwargs = {
        # optionally use GetSeriesQuery to validate and reuse parameters
        "query": GetSeriesQuery(
            return_ingestion_timestamp=False,
        ),
    }
    _get_series_set_mock_response(httpx_mock, gateway_url, quote(str(resourceId)))
    resp = await service.series.get_series(resourceId, **kwargs)
    check_type(resp, List[GetSeries200ResponseInner])


@pytest.mark.asyncio
@pytest.mark.skipif(MODELS_AVAILABLE, reason="Types installed.")
async def test_get_series_without_types(
    service: DataService, gateway_url: str, httpx_mock: HTTPXMock
):
    """Test case for get_series with models not installed
    Get Series Overview
    """
    # set path params
    resourceId = "resource_id_example"

    kwargs = {
        "query": {
            "returnIngestionTimestamp": False,
        },
    }
    _get_series_set_mock_response(httpx_mock, gateway_url, quote(str(resourceId)))
    resp = await service.series.get_series(resourceId, **kwargs)
    check_type(resp, Model)


def _query_time_series_set_mock_response(httpx_mock: HTTPXMock, gateway_url: str):
    mock_response = QueryTimeSeries200ResponseStub.create_json()
    httpx_mock_kwargs = {
        "method": "POST",
        "url": re.compile(f"^{gateway_url}/data/v1/series/query(\\?.*)?"),
        "content": json.dumps(mock_response, default=str),
        "status_code": 200,
    }
    httpx_mock.add_response(**httpx_mock_kwargs)


@pytest.mark.asyncio
@pytest.mark.skipif(not MODELS_AVAILABLE, reason="Types not installed.")
async def test_query_time_series(
    service: DataService, gateway_url: str, httpx_mock: HTTPXMock
):
    """Test case for query_time_series
    Query Series Data
    """
    # set path params
    kwargs = {
        "json": QueryTimeSeriesRequestStub.create_instance(),
    }
    _query_time_series_set_mock_response(httpx_mock, gateway_url)
    resp = await service.series.query_time_series(**kwargs)
    check_type(resp, QueryTimeSeries200Response)


@pytest.mark.asyncio
@pytest.mark.skipif(MODELS_AVAILABLE, reason="Types installed.")
async def test_query_time_series_without_types(
    service: DataService, gateway_url: str, httpx_mock: HTTPXMock
):
    """Test case for query_time_series with models not installed
    Query Series Data
    """
    # set path params
    kwargs = {
        "json": QueryTimeSeriesRequestStub.create_json(),
    }
    _query_time_series_set_mock_response(httpx_mock, gateway_url)
    resp = await service.series.query_time_series(**kwargs)
    check_type(resp, Model)
